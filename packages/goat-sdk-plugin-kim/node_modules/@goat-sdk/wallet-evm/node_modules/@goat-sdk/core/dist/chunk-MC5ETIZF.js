"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunkF25KWNSEjs = require('./chunk-F25KWNSE.js');


var _chunkLBC2NNGYjs = require('./chunk-LBC2NNGY.js');


var _chunkUK53HMGYjs = require('./chunk-UK53HMGY.js');


var _chunk7QVYU63Ejs = require('./chunk-7QVYU63E.js');

// src/classes/PluginBase.ts
var PluginBase = class {
  static {
    _chunk7QVYU63Ejs.__name.call(void 0, this, "PluginBase");
  }
  
  
  /**
   * Creates a new Plugin instance.
   * @param name - The name of the plugin
   * @param toolProviders - Array of class instances that provide tools
   */
  constructor(name, toolProviders) {
    this.name = name;
    this.toolProviders = toolProviders;
  }
  /**
   * Retrieves the tools provided by the plugin.
   * @param wallet - The wallet client to use for tool execution
   * @returns An array of tools
   */
  getTools(walletClient) {
    const tools = [];
    for (const toolProvider of this.toolProviders) {
      const toolsMap = Reflect.getMetadata(toolMetadataKey, toolProvider.constructor);
      if (!toolsMap) {
        const constructorName = toolProvider.constructor.name;
        if (constructorName === "Function") {
          console.warn("Detected a non-instance tool provider. Please ensure you're passing instances of your tool providers, by using `new MyToolProvider(..)`");
        } else {
          console.warn(`No tools found for ${constructorName}. Please ensure you're using the '@Tool' decorator to expose your tools.`);
        }
        continue;
      }
      for (const tool of toolsMap.values()) {
        tools.push(_chunkUK53HMGYjs.createTool.call(void 0, {
          name: tool.name,
          description: tool.description,
          parameters: tool.parameters.schema
        }, (params) => {
          const args = [];
          if (tool.walletClient) {
            args[tool.walletClient.index] = walletClient;
          }
          args[tool.parameters.index] = params;
          return tool.target.apply(toolProvider, args);
        }));
      }
    }
    return tools;
  }
};

// src/decorators/Tool.ts
require('reflect-metadata');
var toolMetadataKey = Symbol("goat:tool");
function Tool(params) {
  return (target, propertyKey, descriptor) => {
    const { parameters, walletClient } = validateMethodParameters(target, propertyKey);
    const existingTools = Reflect.getMetadata(toolMetadataKey, target.constructor) || /* @__PURE__ */ new Map();
    existingTools.set(propertyKey, {
      target: descriptor.value,
      name: _nullishCoalesce(params.name, () => ( _chunkF25KWNSEjs.snakeCase.call(void 0, propertyKey))),
      description: params.description,
      parameters,
      ...walletClient ? {
        walletClient
      } : {}
    });
    Reflect.defineMetadata(toolMetadataKey, existingTools, target.constructor);
    return target;
  };
}
_chunk7QVYU63Ejs.__name.call(void 0, Tool, "Tool");
function validateMethodParameters(target, propertyKey) {
  const className = target instanceof Object ? target.constructor.name : void 0;
  const logPrefix = `Method '${propertyKey}'${className ? ` on class '${className}'` : ""}`;
  const explainer = "Tool methods must have at least one parameter that is a Zod schema class created with the createToolParameters function.";
  const methodParameters = Reflect.getMetadata("design:paramtypes", target, propertyKey);
  if (methodParameters == null) {
    throw new Error(`Failed to get parameters for ${logPrefix}.`);
  }
  if (methodParameters.length === 0) {
    throw new Error(`${logPrefix} has no parameters. ${explainer}`);
  }
  if (methodParameters.length > 2) {
    throw new Error(`${logPrefix} has ${methodParameters.length} parameters. ${explainer}`);
  }
  const parametersParameter = methodParameters.find(isParametersParameter);
  if (parametersParameter == null) {
    throw new Error(`${logPrefix} has no parameters parameter.

1.) ${explainer}

2.) Ensure that you are not using 'import type' for the parameters.`);
  }
  const walletClientParameter = methodParameters.find(isWalletClientParameter);
  return {
    parameters: {
      index: methodParameters.indexOf(parametersParameter),
      schema: parametersParameter.prototype.constructor.schema
    },
    ...walletClientParameter ? {
      walletClient: {
        index: methodParameters.indexOf(walletClientParameter)
      }
    } : {}
  };
}
_chunk7QVYU63Ejs.__name.call(void 0, validateMethodParameters, "validateMethodParameters");
function isWalletClientParameter(param) {
  if (!param || !param.prototype) {
    return false;
  }
  if (param === _chunkLBC2NNGYjs.WalletClientBase) {
    return true;
  }
  return param.prototype instanceof _chunkLBC2NNGYjs.WalletClientBase;
}
_chunk7QVYU63Ejs.__name.call(void 0, isWalletClientParameter, "isWalletClientParameter");
function isParametersParameter(param) {
  return _optionalChain([param, 'access', _ => _.prototype, 'optionalAccess', _2 => _2.constructor, 'optionalAccess', _3 => _3.schema]) != null;
}
_chunk7QVYU63Ejs.__name.call(void 0, isParametersParameter, "isParametersParameter");





exports.toolMetadataKey = toolMetadataKey; exports.Tool = Tool; exports.PluginBase = PluginBase;
//# sourceMappingURL=chunk-MC5ETIZF.js.map