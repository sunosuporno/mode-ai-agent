{"version":3,"sources":["../src/classes/PluginBase.ts","../src/decorators/Tool.ts"],"sourcesContent":["import { type StoredToolMetadataMap, toolMetadataKey } from \"../decorators/Tool\";\nimport type { Chain } from \"../types/Chain\";\nimport { type ToolBase, createTool } from \"./ToolBase\";\nimport type { WalletClientBase } from \"./WalletClientBase\";\n\n/**\n * Abstract base class for plugins that provide tools for wallet interactions.\n */\nexport abstract class PluginBase<TWalletClient extends WalletClientBase = WalletClientBase> {\n    /**\n     * Creates a new Plugin instance.\n     * @param name - The name of the plugin\n     * @param toolProviders - Array of class instances that provide tools\n     */\n    constructor(\n        public readonly name: string,\n        // biome-ignore lint/complexity/noBannedTypes: Object is the correct type, referring to instances of classes\n        public readonly toolProviders: Object[],\n    ) {}\n\n    /**\n     * Checks if the plugin supports a specific blockchain.\n     * @param chain - The blockchain to check support for\n     * @returns True if the chain is supported, false otherwise\n     */\n    abstract supportsChain(chain: Chain): boolean;\n\n    /**\n     * Retrieves the tools provided by the plugin.\n     * @param wallet - The wallet client to use for tool execution\n     * @returns An array of tools\n     */\n    getTools(walletClient: TWalletClient): ToolBase[] | Promise<ToolBase[]> {\n        const tools: ToolBase[] = [];\n\n        for (const toolProvider of this.toolProviders) {\n            const toolsMap = Reflect.getMetadata(toolMetadataKey, toolProvider.constructor) as\n                | StoredToolMetadataMap\n                | undefined;\n\n            if (!toolsMap) {\n                const constructorName = toolProvider.constructor.name;\n                if (constructorName === \"Function\") {\n                    console.warn(\n                        \"Detected a non-instance tool provider. Please ensure you're passing instances of your tool providers, by using `new MyToolProvider(..)`\",\n                    );\n                } else {\n                    console.warn(\n                        `No tools found for ${constructorName}. Please ensure you're using the '@Tool' decorator to expose your tools.`,\n                    );\n                }\n                continue;\n            }\n\n            for (const tool of toolsMap.values()) {\n                tools.push(\n                    createTool(\n                        {\n                            name: tool.name,\n                            description: tool.description,\n                            parameters: tool.parameters.schema,\n                        },\n                        (params) => {\n                            const args = [];\n                            if (tool.walletClient) {\n                                args[tool.walletClient.index] = walletClient;\n                            }\n                            args[tool.parameters.index] = params;\n\n                            return tool.target.apply(toolProvider, args);\n                        },\n                    ),\n                );\n            }\n        }\n\n        return tools;\n    }\n}\n","import type { z } from \"zod\";\nimport { WalletClientBase } from \"../classes\";\nimport { snakeCase } from \"../utils/snakeCase\";\n\nimport \"reflect-metadata\";\n\n/**\n * Parameters for the Tool decorator\n * @template TParameters - The Zod schema type for the tool parameters\n */\nexport type ToolDecoratorParams = {\n    /**\n     * The name of the tool\n     * @default snakeCase(methodName)\n     */\n    name?: string;\n    /** A description of what the tool does */\n    description: string;\n};\n\nexport type StoredToolMetadata = {\n    name: string;\n    description: string;\n    parameters: {\n        index: number;\n        schema: z.ZodSchema;\n    };\n    walletClient?: {\n        index: number;\n    };\n    // biome-ignore lint/complexity/noBannedTypes: Function is the correct type for a descriptor value\n    target: Function;\n};\n\nexport type StoredToolMetadataMap = Map<string, StoredToolMetadata>;\n\nexport const toolMetadataKey = Symbol(\"goat:tool\");\n\n/**\n * Decorator that marks a class method as a tool accessible to the LLM\n * @param params - Configuration parameters for the tool\n * @returns A decorator function that can be applied to class methods\n *\n * @example\n * class MyToolService {\n *     \\@Tool({\n *         description: \"Adds two numbers\",\n *     })\n *     add({a, b}: AddParameters) {\n *         return a + b;\n *     }\n *}\n */\nexport function Tool(params: ToolDecoratorParams) {\n    // biome-ignore lint/complexity/noBannedTypes: Object is the correct type for a class method\n    return (target: Object, propertyKey: string, descriptor: PropertyDescriptor) => {\n        const { parameters, walletClient } = validateMethodParameters(target, propertyKey);\n\n        const existingTools: StoredToolMetadataMap =\n            Reflect.getMetadata(toolMetadataKey, target.constructor) || new Map();\n\n        existingTools.set(propertyKey, {\n            target: descriptor.value,\n            name: params.name ?? snakeCase(propertyKey),\n            description: params.description,\n            parameters: parameters,\n            ...(walletClient ? { walletClient } : {}),\n        });\n\n        Reflect.defineMetadata(toolMetadataKey, existingTools, target.constructor);\n        return target;\n    };\n}\n\nfunction validateMethodParameters(\n    // biome-ignore lint/complexity/noBannedTypes: Object is the correct type for a class method\n    target: Object,\n    propertyKey: string,\n): {\n    parameters: {\n        index: number;\n        schema: z.ZodSchema;\n    };\n    walletClient?: {\n        index: number;\n    };\n} {\n    const className = target instanceof Object ? target.constructor.name : undefined;\n    const logPrefix = `Method '${propertyKey}'${className ? ` on class '${className}'` : \"\"}`;\n    const explainer =\n        \"Tool methods must have at least one parameter that is a Zod schema class created with the createToolParameters function.\";\n\n    const methodParameters = Reflect.getMetadata(\"design:paramtypes\", target, propertyKey);\n\n    if (methodParameters == null) {\n        throw new Error(`Failed to get parameters for ${logPrefix}.`);\n    }\n    if (methodParameters.length === 0) {\n        throw new Error(`${logPrefix} has no parameters. ${explainer}`);\n    }\n    if (methodParameters.length > 2) {\n        throw new Error(`${logPrefix} has ${methodParameters.length} parameters. ${explainer}`);\n    }\n\n    const parametersParameter = methodParameters.find(isParametersParameter);\n    if (parametersParameter == null) {\n        throw new Error(\n            `${logPrefix} has no parameters parameter.\\n\\n1.) ${explainer}\\n\\n2.) Ensure that you are not using 'import type' for the parameters.`,\n        );\n    }\n\n    const walletClientParameter = methodParameters.find(isWalletClientParameter);\n\n    return {\n        parameters: {\n            index: methodParameters.indexOf(parametersParameter) as number,\n            schema: parametersParameter.prototype.constructor.schema,\n        },\n        ...(walletClientParameter\n            ? { walletClient: { index: methodParameters.indexOf(walletClientParameter) as number } }\n            : {}),\n    };\n}\n\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nfunction isWalletClientParameter(param: any) {\n    if (!param || !param.prototype) {\n        return false;\n    }\n    if (param === WalletClientBase) {\n        return true;\n    }\n    return param.prototype instanceof WalletClientBase;\n}\n\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nfunction isParametersParameter(param: any) {\n    return param.prototype?.constructor?.schema != null;\n}\n"],"mappings":"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","names":["PluginBase","constructor","name","toolProviders","getTools","walletClient","tools","toolProvider","toolsMap","Reflect","getMetadata","toolMetadataKey","constructorName","console","warn","tool","values","push","createTool","description","parameters","schema","params","args","index","target","apply","toolMetadataKey","Symbol","Tool","params","target","propertyKey","descriptor","parameters","walletClient","validateMethodParameters","existingTools","Reflect","getMetadata","constructor","Map","set","value","name","snakeCase","description","defineMetadata","className","Object","undefined","logPrefix","explainer","methodParameters","Error","length","parametersParameter","find","isParametersParameter","walletClientParameter","isWalletClientParameter","index","indexOf","schema","prototype","param","WalletClientBase"]}