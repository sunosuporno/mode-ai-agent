import {
  __name
} from "./chunk-PAWJFY3S.mjs";

// src/sendETH.plugin.ts
import { PluginBase, createTool } from "@goat-sdk/core";
import { parseEther } from "viem";
import * as allEVMChains from "viem/chains";
import { z } from "zod";
var SendETHPlugin = class extends PluginBase {
  static {
    __name(this, "SendETHPlugin");
  }
  constructor() {
    super("sendETH", []);
  }
  supportsChain = /* @__PURE__ */ __name((chain) => chain.type === "evm", "supportsChain");
  getTools(walletClient) {
    const sendTool = createTool({
      name: `send_${getChainToken(walletClient.getChain().id).symbol}`,
      description: `Send ${getChainToken(walletClient.getChain().id).symbol} to an address.`,
      parameters: sendETHParametersSchema
    }, (parameters) => sendETHMethod(walletClient, parameters));
    return [
      sendTool
    ];
  }
};
var sendETH = /* @__PURE__ */ __name(() => new SendETHPlugin(), "sendETH");
var sendETHParametersSchema = z.object({
  to: z.string().describe("The address to send ETH to"),
  amount: z.string().describe("The amount of ETH to send")
});
async function sendETHMethod(walletClient, parameters) {
  try {
    const amount = parseEther(parameters.amount);
    const tx = await walletClient.sendTransaction({
      to: parameters.to,
      value: amount
    });
    return tx.hash;
  } catch (error) {
    throw new Error(`Failed to send ${getChainToken(walletClient.getChain().id)}: ${error}`);
  }
}
__name(sendETHMethod, "sendETHMethod");
function getChainToken(chainId) {
  const allChains = Object.values(allEVMChains);
  const viemChain = allChains.find((c) => c.id === chainId);
  if (!viemChain) {
    throw new Error(`Unsupported EVM chain ID: ${chainId}`);
  }
  return {
    symbol: viemChain.nativeCurrency.symbol,
    name: viemChain.nativeCurrency.name,
    decimals: viemChain.nativeCurrency.decimals
  };
}
__name(getChainToken, "getChainToken");

export {
  SendETHPlugin,
  sendETH
};
//# sourceMappingURL=chunk-AE5UVYA4.mjs.map