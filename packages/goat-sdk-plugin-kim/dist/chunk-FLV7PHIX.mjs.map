{"version":3,"sources":["../src/kim.service.ts"],"sourcesContent":["import { Tool } from \"@goat-sdk/core\";\nimport { EVMWalletClient } from \"@goat-sdk/wallet-evm\";\nimport { parseUnits } from \"viem\";\nimport { encodeAbiParameters } from \"viem\";\nimport { ERC20_ABI } from \"./abi/erc20\";\nimport { KIM_FACTORY_ABI } from \"./abi/factory\";\nimport { POOL_ABI } from \"./abi/pool\";\nimport { POSITION_MANAGER_ABI } from \"./abi/positionManager\";\nimport { SWAP_ROUTER_ABI } from \"./abi/swaprouter\";\nimport {\n    BurnParams,\n    CollectParams,\n    DecreaseLiquidityParams,\n    ExactInputParams,\n    ExactInputSingleParams,\n    ExactOutputParams,\n    ExactOutputSingleParams,\n    GetSwapRouterAddressParams,\n    GlobalStateResponseParams,\n    IncreaseLiquidityParams,\n    MintParams,\n} from \"./parameters\";\n\nconst SWAP_ROUTER_ADDRESS = \"0xAc48FcF1049668B285f3dC72483DF5Ae2162f7e8\";\nconst POSITION_MANAGER_ADDRESS = \"0x2e8614625226D26180aDf6530C3b1677d3D7cf10\";\nconst FACTORY_ADDRESS = \"0xB5F00c2C5f8821155D8ed27E31932CFD9DB3C5D5\";\n\nexport class KimService {\n    @Tool({\n        name: \"kim_get_swap_router_address\",\n        description: \"Get the address of the swap router\",\n    })\n    async getSwapRouterAddress(parameters: GetSwapRouterAddressParams) {\n        return SWAP_ROUTER_ADDRESS;\n    }\n\n    @Tool({\n        description:\n            \"Swap an exact amount of input tokens for a single hop. Make sure tokens are approved for the swap router.\",\n    })\n    async swapExactInputSingleHop(walletClient: EVMWalletClient, parameters: ExactInputSingleParams) {\n        try {\n            const recipient = await walletClient.resolveAddress(parameters.recipient);\n\n            const amountIn = parameters.amountIn;\n            const amountOutMinimum = parameters.amountOutMinimum;\n            const limitSqrtPrice = parameters.limitSqrtPrice;\n            const timestamp = Math.floor(Date.now() / 1000) + parameters.deadline;\n\n            const hash = await walletClient.sendTransaction({\n                to: SWAP_ROUTER_ADDRESS,\n                abi: SWAP_ROUTER_ABI,\n                functionName: \"exactInputSingle\",\n                args: [\n                    {\n                        tokenIn: parameters.tokenIn,\n                        tokenOut: parameters.tokenOut,\n                        recipient: recipient,\n                        deadline: timestamp,\n                        amountIn: amountIn,\n                        amountOutMinimum: amountOutMinimum,\n                        limitSqrtPrice: limitSqrtPrice,\n                    },\n                ],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw Error(`Failed to swap: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_swap_exact_output_single_hop\",\n        description: \"Swap an exact amount of output tokens for a single hop\",\n    })\n    async swapExactOutputSingleHop(\n        walletClient: EVMWalletClient,\n        parameters: ExactOutputSingleParams,\n    ): Promise<string> {\n        try {\n            const tokenIn = await walletClient.resolveAddress(parameters.tokenIn);\n            const tokenOut = await walletClient.resolveAddress(parameters.tokenOut);\n            const recipient = await walletClient.resolveAddress(parameters.recipient);\n\n            const tokenInDecimals = Number(\n                await walletClient.read({\n                    address: parameters.tokenIn as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n            );\n\n            const tokenOutDecimals = Number(\n                await walletClient.read({\n                    address: parameters.tokenOut as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n            );\n\n            const amountOut = parseUnits(parameters.amountOut, tokenOutDecimals);\n            const amountInMaximum = parseUnits(parameters.amountInMaximum, tokenInDecimals);\n            const limitSqrtPrice = parseUnits(parameters.limitSqrtPrice, 96);\n\n            const hash = await walletClient.sendTransaction({\n                to: SWAP_ROUTER_ADDRESS,\n                abi: SWAP_ROUTER_ABI,\n                functionName: \"exactOutputSingle\",\n                args: [tokenIn, tokenOut, recipient, parameters.deadline, amountOut, amountInMaximum, limitSqrtPrice],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw Error(`Failed to swap: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_swap_exact_input_multi_hop\",\n        description: \"Swap an exact amount of input tokens in multiple hops\",\n    })\n    async swapExactInputMultiHop(walletClient: EVMWalletClient, parameters: ExactInputParams): Promise<string> {\n        try {\n            const recipient = await walletClient.resolveAddress(parameters.recipient);\n\n            // Get first and last token decimals\n            const tokenInDecimals = Number(\n                await walletClient.read({\n                    address: parameters.path.tokenIn as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n            );\n\n            const tokenOutDecimals = Number(\n                await walletClient.read({\n                    address: parameters.path.tokenOut as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n            );\n\n            // Encode the path\n            const encodedPath = encodeAbiParameters(\n                [{ type: \"address[]\" }, { type: \"uint24[]\" }],\n                [\n                    [\n                        parameters.path.tokenIn as `0x${string}`,\n                        ...parameters.path.intermediateTokens.map((t: string) => t as `0x${string}`),\n                        parameters.path.tokenOut as `0x${string}`,\n                    ],\n                    parameters.path.fees,\n                ],\n            );\n\n            const hash = await walletClient.sendTransaction({\n                to: SWAP_ROUTER_ADDRESS,\n                abi: SWAP_ROUTER_ABI,\n                functionName: \"exactInput\",\n                args: [\n                    encodedPath,\n                    recipient,\n                    parameters.deadline,\n                    parseUnits(parameters.amountIn, tokenInDecimals),\n                    parseUnits(parameters.amountOutMinimum, tokenOutDecimals),\n                ],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw new Error(`Failed to swap: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_swap_exact_output_multi_hop\",\n        description: \"Swap tokens to receive an exact amount of output tokens in multiple hops\",\n    })\n    async swapExactOutputMultiHop(walletClient: EVMWalletClient, parameters: ExactOutputParams): Promise<string> {\n        try {\n            const recipient = await walletClient.resolveAddress(parameters.recipient);\n\n            // Get first and last token decimals\n            const tokenInDecimals = Number(\n                await walletClient.read({\n                    address: parameters.path.tokenIn as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n            );\n\n            const tokenOutDecimals = Number(\n                await walletClient.read({\n                    address: parameters.path.tokenOut as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n            );\n\n            // Encode the path\n            const encodedPath = encodeAbiParameters(\n                [{ type: \"address[]\" }, { type: \"uint24[]\" }],\n                [\n                    [\n                        parameters.path.tokenIn as `0x${string}`,\n                        ...parameters.path.intermediateTokens.map((t: string) => t as `0x${string}`),\n                        parameters.path.tokenOut as `0x${string}`,\n                    ],\n                    parameters.path.fees,\n                ],\n            );\n\n            const hash = await walletClient.sendTransaction({\n                to: SWAP_ROUTER_ADDRESS,\n                abi: SWAP_ROUTER_ABI,\n                functionName: \"exactOutput\",\n                args: [\n                    encodedPath,\n                    recipient,\n                    parameters.deadline,\n                    parseUnits(parameters.amountOut, tokenOutDecimals),\n                    parseUnits(parameters.amountInMaximum, tokenInDecimals),\n                ],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw new Error(`Failed to swap: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_mint_position\",\n        description: \"Mint a new liquidity position\",\n    })\n    async mintPosition(walletClient: EVMWalletClient, parameters: MintParams): Promise<string> {\n        try {\n            const tickSpacing = 60; // This should come from the pool fee tier\n            const recipient = await walletClient.resolveAddress(parameters.recipient);\n            const token0 = await walletClient.resolveAddress(parameters.token0);\n            const token1 = await walletClient.resolveAddress(parameters.token1);\n\n            // Get current tick from globalState\n            const poolAddress = await walletClient.read({\n                address: FACTORY_ADDRESS as `0x${string}`,\n                abi: KIM_FACTORY_ABI,\n                functionName: \"getPool\",\n                args: [token0, token1],\n            });\n\n            const { value } = await walletClient.read({\n                address: poolAddress as unknown as `0x${string}`,\n                abi: POOL_ABI,\n                functionName: \"globalState\",\n            });\n\n            const globalState = value as GlobalStateResponseParams;\n            const currentTick = globalState.tick;\n\n            // Calculate ticks around current price\n            const tickLower = parameters.tickLower\n                ? parameters.tickLower\n                : Math.floor(currentTick / tickSpacing) * tickSpacing - tickSpacing * 2;\n            const tickUpper = parameters.tickUpper\n                ? parameters.tickUpper\n                : Math.floor(currentTick / tickSpacing) * tickSpacing + tickSpacing * 2;\n\n            const [token0Decimals, token1Decimals] = await Promise.all([\n                walletClient.read({\n                    address: parameters.token0 as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n                walletClient.read({\n                    address: parameters.token1 as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n            ]);\n\n            const amount0Desired = parseUnits(parameters.amount0Desired, Number(token0Decimals));\n            const amount1Desired = parseUnits(parameters.amount1Desired, Number(token1Decimals));\n\n            const hash = await walletClient.sendTransaction({\n                to: POSITION_MANAGER_ADDRESS,\n                abi: POSITION_MANAGER_ABI,\n                functionName: \"mint\",\n                args: [\n                    {\n                        token0,\n                        token1,\n                        tickLower,\n                        tickUpper,\n                        amount0Desired,\n                        amount1Desired,\n                        amount0Min: 0, // Consider adding slippage protection\n                        amount1Min: 0, // Consider adding slippage protection\n                        recipient,\n                        deadline: parameters.deadline,\n                    },\n                ],\n            });\n\n            return hash.hash;\n            // TODO get the liquidity and tokenId\n        } catch (error) {\n            throw new Error(`Failed to mint position: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_increase_liquidity\",\n        description: \"Increase liquidity in an existing position\",\n    })\n    async increaseLiquidity(walletClient: EVMWalletClient, parameters: IncreaseLiquidityParams): Promise<string> {\n        try {\n            const [token0Decimals, token1Decimals] = await Promise.all([\n                Number(\n                    await walletClient.read({\n                        address: parameters.token0 as `0x${string}`,\n                        abi: ERC20_ABI,\n                        functionName: \"decimals\",\n                    }),\n                ),\n                Number(\n                    await walletClient.read({\n                        address: parameters.token1 as `0x${string}`,\n                        abi: ERC20_ABI,\n                        functionName: \"decimals\",\n                    }),\n                ),\n            ]);\n\n            const hash = await walletClient.sendTransaction({\n                to: POSITION_MANAGER_ADDRESS,\n                abi: POSITION_MANAGER_ABI,\n                functionName: \"increaseLiquidity\",\n                args: [\n                    {\n                        tokenId: parameters.tokenId,\n                        amount0Desired: parseUnits(parameters.amount0Desired, token0Decimals),\n                        amount1Desired: parseUnits(parameters.amount1Desired, token1Decimals),\n                        amount0Min: parseUnits(parameters.amount0Min, token0Decimals),\n                        amount1Min: parseUnits(parameters.amount1Min, token1Decimals),\n                        deadline: parameters.deadline,\n                    },\n                ],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw new Error(`Failed to increase liquidity: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_decrease_liquidity\",\n        description: \"Decrease liquidity in an existing position\",\n    })\n    async decreaseLiquidity(walletClient: EVMWalletClient, parameters: DecreaseLiquidityParams): Promise<string> {\n        try {\n            const [token0Decimals, token1Decimals] = await Promise.all([\n                Number(\n                    await walletClient.read({\n                        address: parameters.token0 as `0x${string}`,\n                        abi: ERC20_ABI,\n                        functionName: \"decimals\",\n                    }),\n                ),\n                Number(\n                    await walletClient.read({\n                        address: parameters.token1 as `0x${string}`,\n                        abi: ERC20_ABI,\n                        functionName: \"decimals\",\n                    }),\n                ),\n            ]);\n\n            const hash = await walletClient.sendTransaction({\n                to: POSITION_MANAGER_ADDRESS,\n                abi: POSITION_MANAGER_ABI,\n                functionName: \"decreaseLiquidity\",\n                args: [\n                    {\n                        tokenId: parameters.tokenId,\n                        liquidity: parseUnits(parameters.liquidity, 18), // Liquidity has 18 decimals\n                        amount0Min: parseUnits(parameters.amount0Min, token0Decimals),\n                        amount1Min: parseUnits(parameters.amount1Min, token1Decimals),\n                        deadline: parameters.deadline,\n                    },\n                ],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw new Error(`Failed to decrease liquidity: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_collect\",\n        description: \"Collect tokens from a liquidity position\",\n    })\n    async collect(walletClient: EVMWalletClient, parameters: CollectParams): Promise<string> {\n        try {\n            const recipient = await walletClient.resolveAddress(parameters.recipient);\n\n            const [token0Decimals, token1Decimals] = await Promise.all([\n                Number(\n                    await walletClient.read({\n                        address: parameters.token0 as `0x${string}`,\n                        abi: ERC20_ABI,\n                        functionName: \"decimals\",\n                    }),\n                ),\n                Number(\n                    await walletClient.read({\n                        address: parameters.token1 as `0x${string}`,\n                        abi: ERC20_ABI,\n                        functionName: \"decimals\",\n                    }),\n                ),\n            ]);\n\n            const hash = await walletClient.sendTransaction({\n                to: POSITION_MANAGER_ADDRESS,\n                abi: POSITION_MANAGER_ABI,\n                functionName: \"collect\",\n                args: [\n                    {\n                        tokenId: parameters.tokenId,\n                        recipient,\n                        amount0Max: parseUnits(parameters.amount0Max, token0Decimals),\n                        amount1Max: parseUnits(parameters.amount1Max, token1Decimals),\n                    },\n                ],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw new Error(`Failed to collect: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_burn\",\n        description: \"Burn a liquidity position NFT after all tokens have been collected\",\n    })\n    async burn(walletClient: EVMWalletClient, parameters: BurnParams): Promise<string> {\n        try {\n            const hash = await walletClient.sendTransaction({\n                to: POSITION_MANAGER_ADDRESS,\n                abi: POSITION_MANAGER_ABI,\n                functionName: \"burn\",\n                args: [parameters.tokenId],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw new Error(`Failed to burn position: ${error}`);\n        }\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,YAAY;AACrB,SAASC,uBAAuB;AAChC,SAASC,kBAAkB;AAC3B,SAASC,2BAA2B;;;;;;;;;;;;AAoBpC,IAAMC,sBAAsB;AAC5B,IAAMC,2BAA2B;AACjC,IAAMC,kBAAkB;AAEjB,IAAMC,aAAN,MAAMA;SAAAA;;;EACT,MAIMC,qBAAqBC,YAAwC;AAC/D,WAAOL;EACX;EAEA,MAIMM,wBAAwBC,cAA+BF,YAAoC;AAC7F,QAAI;AACA,YAAMG,YAAY,MAAMD,aAAaE,eAAeJ,WAAWG,SAAS;AAExE,YAAME,WAAWL,WAAWK;AAC5B,YAAMC,mBAAmBN,WAAWM;AACpC,YAAMC,iBAAiBP,WAAWO;AAClC,YAAMC,YAAYC,KAAKC,MAAMC,KAAKC,IAAG,IAAK,GAAA,IAAQZ,WAAWa;AAE7D,YAAMC,OAAO,MAAMZ,aAAaa,gBAAgB;QAC5CC,IAAIrB;QACJsB,KAAKC;QACLC,cAAc;QACdC,MAAM;UACF;YACIC,SAASrB,WAAWqB;YACpBC,UAAUtB,WAAWsB;YACrBnB;YACAU,UAAUL;YACVH;YACAC;YACAC;UACJ;;MAER,CAAA;AAEA,aAAOO,KAAKA;IAChB,SAASS,OAAO;AACZ,YAAMC,MAAM,mBAAmBD,KAAAA,EAAO;IAC1C;EACJ;EAEA,MAIME,yBACFvB,cACAF,YACe;AACf,QAAI;AACA,YAAMqB,UAAU,MAAMnB,aAAaE,eAAeJ,WAAWqB,OAAO;AACpE,YAAMC,WAAW,MAAMpB,aAAaE,eAAeJ,WAAWsB,QAAQ;AACtE,YAAMnB,YAAY,MAAMD,aAAaE,eAAeJ,WAAWG,SAAS;AAExE,YAAMuB,kBAAkBC,OACpB,MAAMzB,aAAa0B,KAAK;QACpBC,SAAS7B,WAAWqB;QACpBJ,KAAKa;QACLX,cAAc;MAClB,CAAA,CAAA;AAGJ,YAAMY,mBAAmBJ,OACrB,MAAMzB,aAAa0B,KAAK;QACpBC,SAAS7B,WAAWsB;QACpBL,KAAKa;QACLX,cAAc;MAClB,CAAA,CAAA;AAGJ,YAAMa,YAAYC,WAAWjC,WAAWgC,WAAWD,gBAAAA;AACnD,YAAMG,kBAAkBD,WAAWjC,WAAWkC,iBAAiBR,eAAAA;AAC/D,YAAMnB,iBAAiB0B,WAAWjC,WAAWO,gBAAgB,EAAA;AAE7D,YAAMO,OAAO,MAAMZ,aAAaa,gBAAgB;QAC5CC,IAAIrB;QACJsB,KAAKC;QACLC,cAAc;QACdC,MAAM;UAACC;UAASC;UAAUnB;UAAWH,WAAWa;UAAUmB;UAAWE;UAAiB3B;;MAC1F,CAAA;AAEA,aAAOO,KAAKA;IAChB,SAASS,OAAO;AACZ,YAAMC,MAAM,mBAAmBD,KAAAA,EAAO;IAC1C;EACJ;EAEA,MAIMY,uBAAuBjC,cAA+BF,YAA+C;AACvG,QAAI;AACA,YAAMG,YAAY,MAAMD,aAAaE,eAAeJ,WAAWG,SAAS;AAGxE,YAAMuB,kBAAkBC,OACpB,MAAMzB,aAAa0B,KAAK;QACpBC,SAAS7B,WAAWoC,KAAKf;QACzBJ,KAAKa;QACLX,cAAc;MAClB,CAAA,CAAA;AAGJ,YAAMY,mBAAmBJ,OACrB,MAAMzB,aAAa0B,KAAK;QACpBC,SAAS7B,WAAWoC,KAAKd;QACzBL,KAAKa;QACLX,cAAc;MAClB,CAAA,CAAA;AAIJ,YAAMkB,cAAcC,oBAChB;QAAC;UAAEC,MAAM;QAAY;QAAG;UAAEA,MAAM;QAAW;SAC3C;QACI;UACIvC,WAAWoC,KAAKf;aACbrB,WAAWoC,KAAKI,mBAAmBC,IAAI,CAACC,MAAcA,CAAAA;UACzD1C,WAAWoC,KAAKd;;QAEpBtB,WAAWoC,KAAKO;OACnB;AAGL,YAAM7B,OAAO,MAAMZ,aAAaa,gBAAgB;QAC5CC,IAAIrB;QACJsB,KAAKC;QACLC,cAAc;QACdC,MAAM;UACFiB;UACAlC;UACAH,WAAWa;UACXoB,WAAWjC,WAAWK,UAAUqB,eAAAA;UAChCO,WAAWjC,WAAWM,kBAAkByB,gBAAAA;;MAEhD,CAAA;AAEA,aAAOjB,KAAKA;IAChB,SAASS,OAAO;AACZ,YAAM,IAAIC,MAAM,mBAAmBD,KAAAA,EAAO;IAC9C;EACJ;EAEA,MAIMqB,wBAAwB1C,cAA+BF,YAAgD;AACzG,QAAI;AACA,YAAMG,YAAY,MAAMD,aAAaE,eAAeJ,WAAWG,SAAS;AAGxE,YAAMuB,kBAAkBC,OACpB,MAAMzB,aAAa0B,KAAK;QACpBC,SAAS7B,WAAWoC,KAAKf;QACzBJ,KAAKa;QACLX,cAAc;MAClB,CAAA,CAAA;AAGJ,YAAMY,mBAAmBJ,OACrB,MAAMzB,aAAa0B,KAAK;QACpBC,SAAS7B,WAAWoC,KAAKd;QACzBL,KAAKa;QACLX,cAAc;MAClB,CAAA,CAAA;AAIJ,YAAMkB,cAAcC,oBAChB;QAAC;UAAEC,MAAM;QAAY;QAAG;UAAEA,MAAM;QAAW;SAC3C;QACI;UACIvC,WAAWoC,KAAKf;aACbrB,WAAWoC,KAAKI,mBAAmBC,IAAI,CAACC,MAAcA,CAAAA;UACzD1C,WAAWoC,KAAKd;;QAEpBtB,WAAWoC,KAAKO;OACnB;AAGL,YAAM7B,OAAO,MAAMZ,aAAaa,gBAAgB;QAC5CC,IAAIrB;QACJsB,KAAKC;QACLC,cAAc;QACdC,MAAM;UACFiB;UACAlC;UACAH,WAAWa;UACXoB,WAAWjC,WAAWgC,WAAWD,gBAAAA;UACjCE,WAAWjC,WAAWkC,iBAAiBR,eAAAA;;MAE/C,CAAA;AAEA,aAAOZ,KAAKA;IAChB,SAASS,OAAO;AACZ,YAAM,IAAIC,MAAM,mBAAmBD,KAAAA,EAAO;IAC9C;EACJ;EAEA,MAIMsB,aAAa3C,cAA+BF,YAAyC;AACvF,QAAI;AACA,YAAM8C,cAAc;AACpB,YAAM3C,YAAY,MAAMD,aAAaE,eAAeJ,WAAWG,SAAS;AACxE,YAAM4C,SAAS,MAAM7C,aAAaE,eAAeJ,WAAW+C,MAAM;AAClE,YAAMC,SAAS,MAAM9C,aAAaE,eAAeJ,WAAWgD,MAAM;AAGlE,YAAMC,cAAc,MAAM/C,aAAa0B,KAAK;QACxCC,SAAShC;QACToB,KAAKiC;QACL/B,cAAc;QACdC,MAAM;UAAC2B;UAAQC;;MACnB,CAAA;AAEA,YAAM,EAAEG,MAAK,IAAK,MAAMjD,aAAa0B,KAAK;QACtCC,SAASoB;QACThC,KAAKmC;QACLjC,cAAc;MAClB,CAAA;AAEA,YAAMkC,cAAcF;AACpB,YAAMG,cAAcD,YAAYE;AAGhC,YAAMC,YAAYxD,WAAWwD,YACvBxD,WAAWwD,YACX/C,KAAKC,MAAM4C,cAAcR,WAAAA,IAAeA,cAAcA,cAAc;AAC1E,YAAMW,YAAYzD,WAAWyD,YACvBzD,WAAWyD,YACXhD,KAAKC,MAAM4C,cAAcR,WAAAA,IAAeA,cAAcA,cAAc;AAE1E,YAAM,CAACY,gBAAgBC,cAAAA,IAAkB,MAAMC,QAAQC,IAAI;QACvD3D,aAAa0B,KAAK;UACdC,SAAS7B,WAAW+C;UACpB9B,KAAKa;UACLX,cAAc;QAClB,CAAA;QACAjB,aAAa0B,KAAK;UACdC,SAAS7B,WAAWgD;UACpB/B,KAAKa;UACLX,cAAc;QAClB,CAAA;OACH;AAED,YAAM2C,iBAAiB7B,WAAWjC,WAAW8D,gBAAgBnC,OAAO+B,cAAAA,CAAAA;AACpE,YAAMK,iBAAiB9B,WAAWjC,WAAW+D,gBAAgBpC,OAAOgC,cAAAA,CAAAA;AAEpE,YAAM7C,OAAO,MAAMZ,aAAaa,gBAAgB;QAC5CC,IAAIpB;QACJqB,KAAK+C;QACL7C,cAAc;QACdC,MAAM;UACF;YACI2B;YACAC;YACAQ;YACAC;YACAK;YACAC;YACAE,YAAY;YACZC,YAAY;YACZ/D;YACAU,UAAUb,WAAWa;UACzB;;MAER,CAAA;AAEA,aAAOC,KAAKA;IAEhB,SAASS,OAAO;AACZ,YAAM,IAAIC,MAAM,4BAA4BD,KAAAA,EAAO;IACvD;EACJ;EAEA,MAIM4C,kBAAkBjE,cAA+BF,YAAsD;AACzG,QAAI;AACA,YAAM,CAAC0D,gBAAgBC,cAAAA,IAAkB,MAAMC,QAAQC,IAAI;QACvDlC,OACI,MAAMzB,aAAa0B,KAAK;UACpBC,SAAS7B,WAAW+C;UACpB9B,KAAKa;UACLX,cAAc;QAClB,CAAA,CAAA;QAEJQ,OACI,MAAMzB,aAAa0B,KAAK;UACpBC,SAAS7B,WAAWgD;UACpB/B,KAAKa;UACLX,cAAc;QAClB,CAAA,CAAA;OAEP;AAED,YAAML,OAAO,MAAMZ,aAAaa,gBAAgB;QAC5CC,IAAIpB;QACJqB,KAAK+C;QACL7C,cAAc;QACdC,MAAM;UACF;YACIgD,SAASpE,WAAWoE;YACpBN,gBAAgB7B,WAAWjC,WAAW8D,gBAAgBJ,cAAAA;YACtDK,gBAAgB9B,WAAWjC,WAAW+D,gBAAgBJ,cAAAA;YACtDM,YAAYhC,WAAWjC,WAAWiE,YAAYP,cAAAA;YAC9CQ,YAAYjC,WAAWjC,WAAWkE,YAAYP,cAAAA;YAC9C9C,UAAUb,WAAWa;UACzB;;MAER,CAAA;AAEA,aAAOC,KAAKA;IAChB,SAASS,OAAO;AACZ,YAAM,IAAIC,MAAM,iCAAiCD,KAAAA,EAAO;IAC5D;EACJ;EAEA,MAIM8C,kBAAkBnE,cAA+BF,YAAsD;AACzG,QAAI;AACA,YAAM,CAAC0D,gBAAgBC,cAAAA,IAAkB,MAAMC,QAAQC,IAAI;QACvDlC,OACI,MAAMzB,aAAa0B,KAAK;UACpBC,SAAS7B,WAAW+C;UACpB9B,KAAKa;UACLX,cAAc;QAClB,CAAA,CAAA;QAEJQ,OACI,MAAMzB,aAAa0B,KAAK;UACpBC,SAAS7B,WAAWgD;UACpB/B,KAAKa;UACLX,cAAc;QAClB,CAAA,CAAA;OAEP;AAED,YAAML,OAAO,MAAMZ,aAAaa,gBAAgB;QAC5CC,IAAIpB;QACJqB,KAAK+C;QACL7C,cAAc;QACdC,MAAM;UACF;YACIgD,SAASpE,WAAWoE;YACpBE,WAAWrC,WAAWjC,WAAWsE,WAAW,EAAA;YAC5CL,YAAYhC,WAAWjC,WAAWiE,YAAYP,cAAAA;YAC9CQ,YAAYjC,WAAWjC,WAAWkE,YAAYP,cAAAA;YAC9C9C,UAAUb,WAAWa;UACzB;;MAER,CAAA;AAEA,aAAOC,KAAKA;IAChB,SAASS,OAAO;AACZ,YAAM,IAAIC,MAAM,iCAAiCD,KAAAA,EAAO;IAC5D;EACJ;EAEA,MAIMgD,QAAQrE,cAA+BF,YAA4C;AACrF,QAAI;AACA,YAAMG,YAAY,MAAMD,aAAaE,eAAeJ,WAAWG,SAAS;AAExE,YAAM,CAACuD,gBAAgBC,cAAAA,IAAkB,MAAMC,QAAQC,IAAI;QACvDlC,OACI,MAAMzB,aAAa0B,KAAK;UACpBC,SAAS7B,WAAW+C;UACpB9B,KAAKa;UACLX,cAAc;QAClB,CAAA,CAAA;QAEJQ,OACI,MAAMzB,aAAa0B,KAAK;UACpBC,SAAS7B,WAAWgD;UACpB/B,KAAKa;UACLX,cAAc;QAClB,CAAA,CAAA;OAEP;AAED,YAAML,OAAO,MAAMZ,aAAaa,gBAAgB;QAC5CC,IAAIpB;QACJqB,KAAK+C;QACL7C,cAAc;QACdC,MAAM;UACF;YACIgD,SAASpE,WAAWoE;YACpBjE;YACAqE,YAAYvC,WAAWjC,WAAWwE,YAAYd,cAAAA;YAC9Ce,YAAYxC,WAAWjC,WAAWyE,YAAYd,cAAAA;UAClD;;MAER,CAAA;AAEA,aAAO7C,KAAKA;IAChB,SAASS,OAAO;AACZ,YAAM,IAAIC,MAAM,sBAAsBD,KAAAA,EAAO;IACjD;EACJ;EAEA,MAIMmD,KAAKxE,cAA+BF,YAAyC;AAC/E,QAAI;AACA,YAAMc,OAAO,MAAMZ,aAAaa,gBAAgB;QAC5CC,IAAIpB;QACJqB,KAAK+C;QACL7C,cAAc;QACdC,MAAM;UAACpB,WAAWoE;;MACtB,CAAA;AAEA,aAAOtD,KAAKA;IAChB,SAASS,OAAO;AACZ,YAAM,IAAIC,MAAM,4BAA4BD,KAAAA,EAAO;IACvD;EACJ;AACJ;;;IAlbQoD,MAAM;IACNC,aAAa;;;;;;;;;;IAObA,aACI;;;;;;;;;;;IAmCJD,MAAM;IACNC,aAAa;;;;;;;;;;;IA6CbD,MAAM;IACNC,aAAa;;;;;;;;;;;IAwDbD,MAAM;IACNC,aAAa;;;;;;;;;;;IAwDbD,MAAM;IACNC,aAAa;;;;;;;;;;;IA8EbD,MAAM;IACNC,aAAa;;;;;;;;;;;IA4CbD,MAAM;IACNC,aAAa;;;;;;;;;;;IA2CbD,MAAM;IACNC,aAAa;;;;;;;;;;;IA4CbD,MAAM;IACNC,aAAa;;;;;;;;;","names":["Tool","EVMWalletClient","parseUnits","encodeAbiParameters","SWAP_ROUTER_ADDRESS","POSITION_MANAGER_ADDRESS","FACTORY_ADDRESS","KimService","getSwapRouterAddress","parameters","swapExactInputSingleHop","walletClient","recipient","resolveAddress","amountIn","amountOutMinimum","limitSqrtPrice","timestamp","Math","floor","Date","now","deadline","hash","sendTransaction","to","abi","SWAP_ROUTER_ABI","functionName","args","tokenIn","tokenOut","error","Error","swapExactOutputSingleHop","tokenInDecimals","Number","read","address","ERC20_ABI","tokenOutDecimals","amountOut","parseUnits","amountInMaximum","swapExactInputMultiHop","path","encodedPath","encodeAbiParameters","type","intermediateTokens","map","t","fees","swapExactOutputMultiHop","mintPosition","tickSpacing","token0","token1","poolAddress","KIM_FACTORY_ABI","value","POOL_ABI","globalState","currentTick","tick","tickLower","tickUpper","token0Decimals","token1Decimals","Promise","all","amount0Desired","amount1Desired","POSITION_MANAGER_ABI","amount0Min","amount1Min","increaseLiquidity","tokenId","decreaseLiquidity","liquidity","collect","amount0Max","amount1Max","burn","name","description"]}