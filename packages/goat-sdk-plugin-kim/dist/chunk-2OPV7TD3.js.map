{"version":3,"sources":["/Users/supornosarkar/Hackathons/mode-ai-agent-hackathon/goat/typescript/packages/plugins/kim/dist/chunk-2OPV7TD3.js","../src/kim.service.ts"],"names":["SWAP_ROUTER_ADDRESS","POSITION_MANAGER_ADDRESS","FACTORY_ADDRESS","KimService","getSwapRouterAddress","parameters","swapExactInputSingleHop","walletClient","recipient","resolveAddress","amountIn","amountOutMinimum","limitSqrtPrice","timestamp","Math","floor","Date","now","deadline","hash","sendTransaction","to","abi","SWAP_ROUTER_ABI","functionName","args","tokenIn","tokenOut","error","Error","ERC20_ABI","amountOut","amountInMaximum","encodeAbiParameters","intermediateTokens","fees","encodedPath","tokenInDecimals","tokenOutDecimals","KIM_FACTORY_ABI","token0","token1","read","poolAddress","POOL_ABI","value","tick","tickLower","tickUpper","token1Decimals","POSITION_MANAGER_ABI","amount0Desired","amount1Desired","tokenId"],"mappings":"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","file":"/Users/supornosarkar/Hackathons/mode-ai-agent-hackathon/goat/typescript/packages/plugins/kim/dist/chunk-2OPV7TD3.js","sourcesContent":[null,"import { Tool } from \"@goat-sdk/core\";\nimport { EVMWalletClient } from \"@goat-sdk/wallet-evm\";\nimport { parseUnits } from \"viem\";\nimport { encodeAbiParameters } from \"viem\";\nimport { ERC20_ABI } from \"./abi/erc20\";\nimport { KIM_FACTORY_ABI } from \"./abi/factory\";\nimport { POOL_ABI } from \"./abi/pool\";\nimport { POSITION_MANAGER_ABI } from \"./abi/positionManager\";\nimport { SWAP_ROUTER_ABI } from \"./abi/swaprouter\";\nimport {\n    BurnParams,\n    CollectParams,\n    DecreaseLiquidityParams,\n    ExactInputParams,\n    ExactInputSingleParams,\n    ExactOutputParams,\n    ExactOutputSingleParams,\n    GetSwapRouterAddressParams,\n    GlobalStateResponseParams,\n    IncreaseLiquidityParams,\n    MintParams,\n} from \"./parameters\";\n\nconst SWAP_ROUTER_ADDRESS = \"0xAc48FcF1049668B285f3dC72483DF5Ae2162f7e8\";\nconst POSITION_MANAGER_ADDRESS = \"0x2e8614625226D26180aDf6530C3b1677d3D7cf10\";\nconst FACTORY_ADDRESS = \"0xB5F00c2C5f8821155D8ed27E31932CFD9DB3C5D5\";\n\nexport class KimService {\n    @Tool({\n        name: \"kim_get_swap_router_address\",\n        description: \"Get the address of the swap router\",\n    })\n    async getSwapRouterAddress(parameters: GetSwapRouterAddressParams) {\n        return SWAP_ROUTER_ADDRESS;\n    }\n\n    @Tool({\n        description:\n            \"Swap an exact amount of input tokens for a single hop. Make sure tokens are approved for the swap router.\",\n    })\n    async swapExactInputSingleHop(walletClient: EVMWalletClient, parameters: ExactInputSingleParams) {\n        try {\n            const recipient = await walletClient.resolveAddress(parameters.recipient);\n\n            const amountIn = parameters.amountIn;\n            const amountOutMinimum = parameters.amountOutMinimum;\n            const limitSqrtPrice = parameters.limitSqrtPrice;\n            const timestamp = Math.floor(Date.now() / 1000) + parameters.deadline;\n\n            const hash = await walletClient.sendTransaction({\n                to: SWAP_ROUTER_ADDRESS,\n                abi: SWAP_ROUTER_ABI,\n                functionName: \"exactInputSingle\",\n                args: [\n                    {\n                        tokenIn: parameters.tokenIn,\n                        tokenOut: parameters.tokenOut,\n                        recipient: recipient,\n                        deadline: timestamp,\n                        amountIn: amountIn,\n                        amountOutMinimum: amountOutMinimum,\n                        limitSqrtPrice: limitSqrtPrice,\n                    },\n                ],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw Error(`Failed to swap: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_swap_exact_output_single_hop\",\n        description: \"Swap an exact amount of output tokens for a single hop\",\n    })\n    async swapExactOutputSingleHop(\n        walletClient: EVMWalletClient,\n        parameters: ExactOutputSingleParams,\n    ): Promise<string> {\n        try {\n            const tokenIn = await walletClient.resolveAddress(parameters.tokenIn);\n            const tokenOut = await walletClient.resolveAddress(parameters.tokenOut);\n            const recipient = await walletClient.resolveAddress(parameters.recipient);\n\n            const tokenInDecimals = Number(\n                await walletClient.read({\n                    address: parameters.tokenIn as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n            );\n\n            const tokenOutDecimals = Number(\n                await walletClient.read({\n                    address: parameters.tokenOut as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n            );\n\n            const amountOut = parseUnits(parameters.amountOut, tokenOutDecimals);\n            const amountInMaximum = parseUnits(parameters.amountInMaximum, tokenInDecimals);\n            const limitSqrtPrice = parseUnits(parameters.limitSqrtPrice, 96);\n\n            const hash = await walletClient.sendTransaction({\n                to: SWAP_ROUTER_ADDRESS,\n                abi: SWAP_ROUTER_ABI,\n                functionName: \"exactOutputSingle\",\n                args: [tokenIn, tokenOut, recipient, parameters.deadline, amountOut, amountInMaximum, limitSqrtPrice],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw Error(`Failed to swap: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_swap_exact_input_multi_hop\",\n        description: \"Swap an exact amount of input tokens in multiple hops\",\n    })\n    async swapExactInputMultiHop(walletClient: EVMWalletClient, parameters: ExactInputParams): Promise<string> {\n        try {\n            const recipient = await walletClient.resolveAddress(parameters.recipient);\n\n            // Get first and last token decimals\n            const tokenInDecimals = Number(\n                await walletClient.read({\n                    address: parameters.path.tokenIn as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n            );\n\n            const tokenOutDecimals = Number(\n                await walletClient.read({\n                    address: parameters.path.tokenOut as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n            );\n\n            // Encode the path\n            const encodedPath = encodeAbiParameters(\n                [{ type: \"address[]\" }, { type: \"uint24[]\" }],\n                [\n                    [\n                        parameters.path.tokenIn as `0x${string}`,\n                        ...parameters.path.intermediateTokens.map((t: string) => t as `0x${string}`),\n                        parameters.path.tokenOut as `0x${string}`,\n                    ],\n                    parameters.path.fees,\n                ],\n            );\n\n            const hash = await walletClient.sendTransaction({\n                to: SWAP_ROUTER_ADDRESS,\n                abi: SWAP_ROUTER_ABI,\n                functionName: \"exactInput\",\n                args: [\n                    encodedPath,\n                    recipient,\n                    parameters.deadline,\n                    parseUnits(parameters.amountIn, tokenInDecimals),\n                    parseUnits(parameters.amountOutMinimum, tokenOutDecimals),\n                ],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw new Error(`Failed to swap: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_swap_exact_output_multi_hop\",\n        description: \"Swap tokens to receive an exact amount of output tokens in multiple hops\",\n    })\n    async swapExactOutputMultiHop(walletClient: EVMWalletClient, parameters: ExactOutputParams): Promise<string> {\n        try {\n            const recipient = await walletClient.resolveAddress(parameters.recipient);\n\n            // Get first and last token decimals\n            const tokenInDecimals = Number(\n                await walletClient.read({\n                    address: parameters.path.tokenIn as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n            );\n\n            const tokenOutDecimals = Number(\n                await walletClient.read({\n                    address: parameters.path.tokenOut as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n            );\n\n            // Encode the path\n            const encodedPath = encodeAbiParameters(\n                [{ type: \"address[]\" }, { type: \"uint24[]\" }],\n                [\n                    [\n                        parameters.path.tokenIn as `0x${string}`,\n                        ...parameters.path.intermediateTokens.map((t: string) => t as `0x${string}`),\n                        parameters.path.tokenOut as `0x${string}`,\n                    ],\n                    parameters.path.fees,\n                ],\n            );\n\n            const hash = await walletClient.sendTransaction({\n                to: SWAP_ROUTER_ADDRESS,\n                abi: SWAP_ROUTER_ABI,\n                functionName: \"exactOutput\",\n                args: [\n                    encodedPath,\n                    recipient,\n                    parameters.deadline,\n                    parseUnits(parameters.amountOut, tokenOutDecimals),\n                    parseUnits(parameters.amountInMaximum, tokenInDecimals),\n                ],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw new Error(`Failed to swap: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_mint_position\",\n        description: \"Mint a new liquidity position\",\n    })\n    async mintPosition(walletClient: EVMWalletClient, parameters: MintParams): Promise<string> {\n        try {\n            const tickSpacing = 60; // This should come from the pool fee tier\n            const recipient = await walletClient.resolveAddress(parameters.recipient);\n            const token0 = await walletClient.resolveAddress(parameters.token0);\n            const token1 = await walletClient.resolveAddress(parameters.token1);\n\n            // Get current tick from globalState\n            const poolAddress = await walletClient.read({\n                address: FACTORY_ADDRESS as `0x${string}`,\n                abi: KIM_FACTORY_ABI,\n                functionName: \"getPool\",\n                args: [token0, token1],\n            });\n\n            const { value } = await walletClient.read({\n                address: poolAddress as unknown as `0x${string}`,\n                abi: POOL_ABI,\n                functionName: \"globalState\",\n            });\n\n            const globalState = value as GlobalStateResponseParams;\n            const currentTick = globalState.tick;\n\n            // Calculate ticks around current price\n            const tickLower = parameters.tickLower\n                ? parameters.tickLower\n                : Math.floor(currentTick / tickSpacing) * tickSpacing - tickSpacing * 2;\n            const tickUpper = parameters.tickUpper\n                ? parameters.tickUpper\n                : Math.floor(currentTick / tickSpacing) * tickSpacing + tickSpacing * 2;\n\n            const [token0Decimals, token1Decimals] = await Promise.all([\n                walletClient.read({\n                    address: parameters.token0 as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n                walletClient.read({\n                    address: parameters.token1 as `0x${string}`,\n                    abi: ERC20_ABI,\n                    functionName: \"decimals\",\n                }),\n            ]);\n\n            const amount0Desired = parseUnits(parameters.amount0Desired, Number(token0Decimals));\n            const amount1Desired = parseUnits(parameters.amount1Desired, Number(token1Decimals));\n\n            const hash = await walletClient.sendTransaction({\n                to: POSITION_MANAGER_ADDRESS,\n                abi: POSITION_MANAGER_ABI,\n                functionName: \"mint\",\n                args: [\n                    {\n                        token0,\n                        token1,\n                        tickLower,\n                        tickUpper,\n                        amount0Desired,\n                        amount1Desired,\n                        amount0Min: 0, // Consider adding slippage protection\n                        amount1Min: 0, // Consider adding slippage protection\n                        recipient,\n                        deadline: parameters.deadline,\n                    },\n                ],\n            });\n\n            return hash.hash;\n            // TODO get the liquidity and tokenId\n        } catch (error) {\n            throw new Error(`Failed to mint position: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_increase_liquidity\",\n        description: \"Increase liquidity in an existing position\",\n    })\n    async increaseLiquidity(walletClient: EVMWalletClient, parameters: IncreaseLiquidityParams): Promise<string> {\n        try {\n            const [token0Decimals, token1Decimals] = await Promise.all([\n                Number(\n                    await walletClient.read({\n                        address: parameters.token0 as `0x${string}`,\n                        abi: ERC20_ABI,\n                        functionName: \"decimals\",\n                    }),\n                ),\n                Number(\n                    await walletClient.read({\n                        address: parameters.token1 as `0x${string}`,\n                        abi: ERC20_ABI,\n                        functionName: \"decimals\",\n                    }),\n                ),\n            ]);\n\n            const hash = await walletClient.sendTransaction({\n                to: POSITION_MANAGER_ADDRESS,\n                abi: POSITION_MANAGER_ABI,\n                functionName: \"increaseLiquidity\",\n                args: [\n                    {\n                        tokenId: parameters.tokenId,\n                        amount0Desired: parseUnits(parameters.amount0Desired, token0Decimals),\n                        amount1Desired: parseUnits(parameters.amount1Desired, token1Decimals),\n                        amount0Min: parseUnits(parameters.amount0Min, token0Decimals),\n                        amount1Min: parseUnits(parameters.amount1Min, token1Decimals),\n                        deadline: parameters.deadline,\n                    },\n                ],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw new Error(`Failed to increase liquidity: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_decrease_liquidity\",\n        description: \"Decrease liquidity in an existing position\",\n    })\n    async decreaseLiquidity(walletClient: EVMWalletClient, parameters: DecreaseLiquidityParams): Promise<string> {\n        try {\n            const [token0Decimals, token1Decimals] = await Promise.all([\n                Number(\n                    await walletClient.read({\n                        address: parameters.token0 as `0x${string}`,\n                        abi: ERC20_ABI,\n                        functionName: \"decimals\",\n                    }),\n                ),\n                Number(\n                    await walletClient.read({\n                        address: parameters.token1 as `0x${string}`,\n                        abi: ERC20_ABI,\n                        functionName: \"decimals\",\n                    }),\n                ),\n            ]);\n\n            const hash = await walletClient.sendTransaction({\n                to: POSITION_MANAGER_ADDRESS,\n                abi: POSITION_MANAGER_ABI,\n                functionName: \"decreaseLiquidity\",\n                args: [\n                    {\n                        tokenId: parameters.tokenId,\n                        liquidity: parseUnits(parameters.liquidity, 18), // Liquidity has 18 decimals\n                        amount0Min: parseUnits(parameters.amount0Min, token0Decimals),\n                        amount1Min: parseUnits(parameters.amount1Min, token1Decimals),\n                        deadline: parameters.deadline,\n                    },\n                ],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw new Error(`Failed to decrease liquidity: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_collect\",\n        description: \"Collect tokens from a liquidity position\",\n    })\n    async collect(walletClient: EVMWalletClient, parameters: CollectParams): Promise<string> {\n        try {\n            const recipient = await walletClient.resolveAddress(parameters.recipient);\n\n            const [token0Decimals, token1Decimals] = await Promise.all([\n                Number(\n                    await walletClient.read({\n                        address: parameters.token0 as `0x${string}`,\n                        abi: ERC20_ABI,\n                        functionName: \"decimals\",\n                    }),\n                ),\n                Number(\n                    await walletClient.read({\n                        address: parameters.token1 as `0x${string}`,\n                        abi: ERC20_ABI,\n                        functionName: \"decimals\",\n                    }),\n                ),\n            ]);\n\n            const hash = await walletClient.sendTransaction({\n                to: POSITION_MANAGER_ADDRESS,\n                abi: POSITION_MANAGER_ABI,\n                functionName: \"collect\",\n                args: [\n                    {\n                        tokenId: parameters.tokenId,\n                        recipient,\n                        amount0Max: parseUnits(parameters.amount0Max, token0Decimals),\n                        amount1Max: parseUnits(parameters.amount1Max, token1Decimals),\n                    },\n                ],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw new Error(`Failed to collect: ${error}`);\n        }\n    }\n\n    @Tool({\n        name: \"kim_burn\",\n        description: \"Burn a liquidity position NFT after all tokens have been collected\",\n    })\n    async burn(walletClient: EVMWalletClient, parameters: BurnParams): Promise<string> {\n        try {\n            const hash = await walletClient.sendTransaction({\n                to: POSITION_MANAGER_ADDRESS,\n                abi: POSITION_MANAGER_ABI,\n                functionName: \"burn\",\n                args: [parameters.tokenId],\n            });\n\n            return hash.hash;\n        } catch (error) {\n            throw new Error(`Failed to burn position: ${error}`);\n        }\n    }\n}\n"]}